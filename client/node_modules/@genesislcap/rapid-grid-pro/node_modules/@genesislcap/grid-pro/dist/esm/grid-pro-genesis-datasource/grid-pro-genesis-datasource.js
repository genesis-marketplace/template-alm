import { __awaiter, __decorate } from "tslib";
import { Auth, Datasource, DatasourceDefaults, MessageType, ResourceType, dataServerResultFilter, normaliseCriteria, } from '@genesislcap/foundation-comms';
import { LifecycleMixin } from '@genesislcap/foundation-utils';
import { DOM, attr, customElement, observable } from '@microsoft/fast-element';
import { BehaviorSubject, EMPTY } from 'rxjs';
import { catchError, debounceTime, skip, tap } from 'rxjs/operators';
import { GridProBaseDatasource } from '../datasource/base.datasource';
import { getClientSideFilterParamsByFieldType } from '../datasource/client-side.grid-definitions';
import { logger } from '../utils/logger';
import { gridProGenesisDatasourceEventNames } from './grid-pro-genesis-datasource.config';
const criteriaDelimiter = ';';
const criteriaJoin = ' && ';
const withoutFullInit = null;
const withoutColumnDefs = null;
/**
 * The Genesis Datasource element, for CSRM-compatible data fetching and used exclusively by the GridPro element.
 * @remarks Only supports Client-Side Row Model.
 * @public
 */
let GridProGenesisDatasource = class GridProGenesisDatasource extends LifecycleMixin(GridProBaseDatasource) {
    constructor() {
        super(...arguments);
        this.applyFuncName = 'applyTransaction';
        this.applyAsyncFuncName = 'applyTransactionAsync';
        this.pollingInterval = DatasourceDefaults.REQ_REP_POLLING_INTERVAL_MS;
        this.disablePolling = false;
        this.restartOnReconnection = false;
        this.keepColDefsOnClearRowData = false;
        this.requiresFullRowDataAndColDefs = true;
        this.criteriaFromFilters = new Map();
        this.update = new BehaviorSubject(new Map());
    }
    // DatasourceOptions
    criteriaChanged(oldCriteria, newCriteria) {
        const criteriaIsNotDuplicate = oldCriteria !== normaliseCriteria(newCriteria, criteriaDelimiter);
        if (this.datasource.initialized && criteriaIsNotDuplicate) {
            this.reloadResourceData();
        }
    }
    requestChanged(oldRequest, newRequest) {
        const requestIsNotDuplicate = oldRequest !== newRequest;
        if (this.datasource.initialized && requestIsNotDuplicate) {
            this.reloadResourceData();
        }
    }
    resourceNameChanged(oldValue, newValue) {
        if (!oldValue || oldValue === newValue)
            return;
        this.restart();
    }
    connectedCallback() {
        super.connectedCallback();
        const shouldRunConnect = this.shouldRunConnect;
        DOM.queueUpdate(() => {
            if (!shouldRunConnect)
                return;
            this.init();
        });
        this.connectionSub = this.connect.isConnected$.subscribe((isConnected) => {
            var _a;
            if (isConnected && ((_a = this.agGrid) === null || _a === void 0 ? void 0 : _a.attributes['ds-disconnected'])) {
                this.agGrid.removeAttribute('ds-disconnected');
                if (this.restartOnReconnection) {
                    this.reloadResourceData();
                }
            }
            if (!isConnected) {
                this.agGrid.setAttribute('ds-disconnected', 'ds-disconnected');
            }
        });
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        const shouldRunDisconnect = this.shouldRunDisconnect;
        DOM.queueUpdate(() => {
            if (!shouldRunDisconnect)
                return;
            this.deinit();
        });
    }
    deepClone() {
        const copy = super.deepClone();
        copy.deferredGridOptions = {};
        if (this.deferredGridOptions) {
            Object.keys(this.deferredGridOptions).forEach((key) => {
                if (typeof this.deferredGridOptions[key] === 'function') {
                    copy.deferredGridOptions[key] = this.deferredGridOptions[key].bind(copy);
                }
                else if (key === 'columnDefs' && this.deferredGridOptions[key].length) {
                    copy.deferredGridOptions[key] = this.colDefsDeepClone(key, copy);
                }
                else {
                    copy.deferredGridOptions[key] = structuredClone(this.deferredGridOptions[key]);
                }
            });
        }
        copy.deferredColumnStates = structuredClone(this.deferredColumnStates);
        copy.request = structuredClone(this.request);
        return copy;
    }
    colDefsDeepClone(key, copy) {
        return this.deferredGridOptions[key].map((columnDefinition) => {
            const definitionCopy = {};
            Object.keys(columnDefinition).forEach((fieldKey) => {
                if (typeof columnDefinition[fieldKey] === 'function') {
                    definitionCopy[fieldKey] = columnDefinition[fieldKey].bind(copy);
                }
                else {
                    definitionCopy[fieldKey] = structuredClone(columnDefinition[fieldKey]);
                }
            });
            return definitionCopy;
        });
    }
    // Genesis Specific
    /**
     * Initializes the datasource.
     * @public
     * @param columnDefinitions - Optionally set the `gridOptions` up with column definitions
     * @param columnStates  - Optionally set the grid up with column state
     * @remarks This method is called automatically when the element is connected to the DOM.
     */
    init(columnDefinitions, columnStates) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.agGrid &&
                this.datasource.validResourceName(this.resourceName) &&
                this.connect.isConnected) {
                try {
                    const meta = yield this.connect.getMetadata(this.resourceName);
                    if (!meta) {
                        // TODO: improve getMetadata implementation to return error details
                        this.handleErrors(`No metadata found for ${this.resourceName}, datasource will not work. Falling back to local columnDefs/rowData.`);
                        return;
                    }
                    this.isRequestServer = meta.TYPE === ResourceType.REQUEST_SERVER;
                }
                catch ({ receivedMessage: { ERROR: errors } }) {
                    this.handleErrors(errors.join(', '));
                }
                const gridOptions = Object.assign(Object.assign({ getRowId: (params) => params.data[this.rowId] }, (columnDefinitions && { columnDefs: columnDefinitions })), this.deferredGridOptions);
                this.agGrid.gridOptions = Object.assign({}, gridOptions);
                this.agGrid.addEventListener('onGridReady', () => __awaiter(this, void 0, void 0, function* () {
                    if (columnStates) {
                        this.agGrid.columnApi.applyColumnState({ state: columnStates });
                    }
                    yield this.loadResourceData();
                }), { once: true });
                const filterDebounceTime = 600;
                this.updateSub = this.update
                    .pipe(skip(1), debounceTime(filterDebounceTime), tap((f) => logger.debug('filters (debounced): ', f)))
                    .subscribe((_) => {
                    this.reloadResourceData();
                });
                return;
            }
            this.handleErrors('Application not connected or invalid resource name, datasource will not work. Falling back to local columnDefs/rowData.');
        });
    }
    /**
     * Deinitialises the datasource, resetting it to its initial state.
     * @public
     */
    deinit() {
        this.reset();
    }
    /**
     * Resets the datasource to its initial state.
     * @public
     * @deprecated Use `deinit` instead
     */
    reset() {
        var _a;
        logger.debug('GridProGenesisDatasource.reset()', this.resourceName);
        if (this.dataSub) {
            this.dataSub.unsubscribe();
            this.dataSub = undefined;
        }
        if (this.updateSub) {
            this.updateSub.unsubscribe();
            this.updateSub = undefined;
        }
        if (this.connectionSub) {
            this.connectionSub.unsubscribe();
            this.connectionSub = undefined;
        }
        this.sourceRef = undefined;
        this.clearRowData();
        this.isRequestServer = false;
        this.requiresFullRowDataAndColDefs = true;
        this.dataSubWasLoggedOff = false;
        this.criteriaFromFilters = new Map();
        (_a = this.update) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        this.update = new BehaviorSubject(new Map());
        this.agGrid.removeAttribute('ds-disconnected');
        // TODO: There may need to be a full destroy path. Datasources need some love!
        this.datasource.deinit();
    }
    /**
     * Restarts the datasource, uses `deinit` and `init` in sequence.
     * @public
     */
    restart() {
        let columnDefinitions;
        let columnStates;
        if (this.keepColDefsOnClearRowData) {
            columnDefinitions = this.agGrid.gridApi.getColumnDefs();
            columnStates = this.agGrid.columnApi.getColumnState();
        }
        this.deinit();
        this.init(columnDefinitions, columnStates);
    }
    /**
     * Force the grid to redispatch the current rows
     */
    refreshRows() {
        this.setRowData(Array.from(this.rowData.values()));
    }
    /**
     * Clears the rowData and columnDefs for the grid.
     * @remarks This is called when `reloadResourceData` happens, on criteria and filters change or full `reset`.
     * @param withColumnDefs - Whether to clear the columnDefs as well. Defaults to true.
     * @internal
     */
    clearRowData(withColumnDefs = true) {
        var _a, _b, _c, _d;
        this.rowData = new Map();
        this.agTransaction = undefined;
        if (withColumnDefs && !this.keepColDefsOnClearRowData) {
            (_b = (_a = this.agGrid) === null || _a === void 0 ? void 0 : _a.gridApi) === null || _b === void 0 ? void 0 : _b.setColumnDefs([]);
        }
        (_d = (_c = this.agGrid) === null || _c === void 0 ? void 0 : _c.gridApi) === null || _d === void 0 ? void 0 : _d.setRowData([]);
    }
    /**
     * Sets the columnDefs and rowData for the grid.
     * @remarks This should only happen once, when the grid is first initialized. Follow up updates will use the agTransaction.
     * @internal
     */
    setRowData(rowData) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const preSetColumnDefs = (_a = this.agGrid.gridApi) === null || _a === void 0 ? void 0 : _a.getColumnDefs();
            if (!preSetColumnDefs || preSetColumnDefs.length === 0) {
                const agColumnDefs = yield this.getAgColumnDefs(this.datasource.fieldMetadata);
                if (agColumnDefs) {
                    // AG's internals will check if group/pivot are NOT NULL to trigger module registration warning for `row-grouping`.
                    // When using gridApi to get the currentState to save, all boolean will return false when they were not set at all.
                    // ColDef type is `boolean` while ColumnState is `boolean | null`.
                    agColumnDefs.forEach((col) => {
                        if (!col.rowGroup) {
                            col.rowGroup = null;
                        }
                        if (!col.pivot) {
                            col.pivot = null;
                        }
                    });
                    this.agGrid.gridApi.setColumnDefs(agColumnDefs);
                }
            }
            const data = this.rowDataMapper ? this.rowDataMapper(rowData) : rowData;
            this.agGrid.restoreCachedFilterConfig();
            this.agTransaction = { add: [...data], remove: [], update: [], addIndex: 0 };
            this.applyAllAgTransactions();
            this.requiresFullRowDataAndColDefs = false;
        });
    }
    /**
     * Resets the grid data while keeping columnDefs and sends a DATA_LOGOFF message if it's a stream.
     * Proxies to {@link @genesislcap/grid-pro#GridProGenesisDatasource.loadResourceData} but without the full init (no metadata fetch).
     * @remarks This is used when the grid is already initialized and we want to reload the data due to a criteria/filter change.
     * @internal
     */
    reloadResourceData() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            logger.debug('GridProGenesisDatasource.reloadResourceData()', this.resourceName);
            if (this.dataSub) {
                this.dataSub.unsubscribe();
                this.dataSub = undefined;
            }
            this.clearRowData(withoutColumnDefs);
            (_b = (_a = this.agGrid) === null || _a === void 0 ? void 0 : _a.gridApi) === null || _b === void 0 ? void 0 : _b.showLoadingOverlay();
            this.agGrid.removeAttribute('ds-disconnected');
            this.loadResourceData(withoutFullInit);
        });
    }
    /**
     * Initializes the datasource and loads the data for the grid.
     * Handles both snapshot and stream data (for both REQUEST_SERVER and DATASERVER resource types).
     *
     * @param withFullInit - if true, will call datasource.init() with requiresMetadataFetch = true, fetching fresh metadata
     * @internal
     */
    loadResourceData(withFullInit = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const requiresMetadataFetch = withFullInit || !this.datasource.initialized;
            try {
                const initOK = yield this.datasource.init(this.datasourceOptions(), requiresMetadataFetch);
                if (!initOK) {
                    logger.debug(`Genesis Datasource init failed for ${this.resourceName}`);
                    this.clearRowData();
                    return;
                }
                this.$emit(gridProGenesisDatasourceEventNames.dataInit);
                if (this.isSnapshot) {
                    const result = yield this.datasource.snapshot();
                    if (result) {
                        const rowData = this.handleSnapshot(result);
                        this.setRowData(rowData);
                    }
                    return;
                }
                logger.debug(`requesting stream for ${this.resourceName}`);
                this.dataSub = this.datasource.stream
                    .pipe(catchError((err) => {
                    var _a;
                    this.handleErrors((_a = err === null || err === void 0 ? void 0 : err.receivedMessage) === null || _a === void 0 ? void 0 : _a.ERROR.join(', '));
                    return EMPTY;
                }))
                    .subscribe((result) => {
                    if (result === null || result === void 0 ? void 0 : result.ERROR) {
                        this.handleErrors(result.ERROR.join(', '));
                    }
                    this.sourceRef = result.SOURCE_REF;
                    const messageType = result.MESSAGE_TYPE;
                    if (messageType && messageType === MessageType.LOGOFF_ACK) {
                        this.handleErrors(`Genesis datasource for ${this.resourceName} disconnected.`);
                        this.dataSubWasLoggedOff = true;
                        return;
                    }
                    this.dataSubWasLoggedOff = false;
                    if (result.ROW) {
                        const nextMessage = dataServerResultFilter(result);
                        this.handleStreamResult(nextMessage);
                    }
                    else {
                        this.handleStreamResult(result);
                    }
                });
            }
            catch (error) {
                let { message } = error;
                if (error.receivedMessage) {
                    message = error.receivedMessage.ERROR;
                }
                logger.error(message);
                this.handleErrors(message);
            }
        });
    }
    handleSnapshot(result) {
        if (Array.isArray(result))
            return result;
        if (result.REPLY) {
            return result.REPLY;
        }
        if (result.ROW) {
            return dataServerResultFilter(result).inserts;
        }
        return result.inserts;
    }
    handleErrors(message) {
        if (this.agGrid) {
            this.agGrid.setAttribute('ds-disconnected', 'ds-disconnected');
        }
        if (message) {
            logger.warn(message);
            this.$emit(gridProGenesisDatasourceEventNames.error, { message });
        }
    }
    datasourceOptions() {
        return {
            criteria: this.buildCriteria(),
            fields: this.fields,
            isSnapshot: this.isSnapshot,
            maxRows: this.maxRows,
            maxView: this.maxView,
            movingView: this.movingView,
            orderBy: this.orderBy,
            pollingInterval: this.pollingInterval,
            disablePolling: this.disablePolling,
            request: this.request,
            resourceName: this.resourceName,
            reverse: this.reverse,
        };
    }
    handleStreamResult(result) {
        if (!result)
            return;
        if (this.isRequestServer) {
            this.applyRequestServerData(result);
        }
        else {
            this.applyDataserverData(result);
        }
    }
    applyRequestServerData(requestServerResult) {
        var _a;
        const previousSize = this.rowData.size;
        const requestServerData = requestServerResult.REPLY;
        if (!Array.isArray(requestServerData) ||
            !((_a = requestServerResult.MESSAGE_TYPE) === null || _a === void 0 ? void 0 : _a.startsWith('REP_'))) {
            logger.error('received invalid RequestServerResult', requestServerResult);
            return;
        }
        if (this.requiresFullRowDataAndColDefs) {
            requestServerData === null || requestServerData === void 0 ? void 0 : requestServerData.forEach((insertData) => {
                this.rowData.set(insertData[this.rowId], insertData);
            });
            const rowData = this.rowData.size > 0 ? Array.from(this.rowData.values()) : requestServerData;
            this.handleSizeChanged(previousSize, this.rowData.size);
            this.setRowData(rowData);
            return;
        }
        const rowsToUpdate = [];
        const rowsToDelete = Array.from(this.rowData.values()).filter((row) => {
            const match = requestServerData.find((data) => data[this.rowId] === row[this.rowId]);
            if (match) {
                rowsToUpdate.push(match);
                return false; // don't delete rows that need to be updated
            }
            return true; // delete rows that don't exist in requestServerData
        });
        const rowsToInsert = requestServerData.filter((data) => !this.rowData.has(data[this.rowId]));
        this.agTransaction = { add: [], remove: [], update: [] };
        this.handleStreamInserts(rowsToInsert);
        this.handleStreamDeletes(rowsToDelete);
        this.handleStreamUpdates(rowsToUpdate);
        this.applyAllAgTransactions();
        this.handleSizeChanged(previousSize, this.rowData.size);
    }
    applyDataserverData(dataServerResult) {
        var _a;
        const previousSize = this.rowData.size;
        if (this.requiresFullRowDataAndColDefs) {
            (_a = dataServerResult.inserts) === null || _a === void 0 ? void 0 : _a.forEach((insertData) => {
                this.rowData.set(insertData[this.rowId], insertData);
            });
            const rowData = Array.from(this.rowData.values());
            this.setRowData(rowData);
            this.handleSizeChanged(previousSize, this.rowData.size);
            return;
        }
        this.agTransaction = { add: [], remove: [], update: [] };
        this.handleStreamInserts(dataServerResult.inserts);
        this.handleStreamDeletes(dataServerResult.deletes);
        this.handleStreamUpdates(dataServerResult.updates);
        this.applyAllAgTransactions();
        this.handleSizeChanged(previousSize, this.rowData.size);
    }
    // FUTURE: Work with the field types vs ag grid column def types!
    getAgColumnDefs(fieldsMetadata) {
        return __awaiter(this, void 0, void 0, function* () {
            const columnDefsFromMetadata = this.generateColumnDefsFromMetadata(fieldsMetadata, getClientSideFilterParamsByFieldType);
            const colDefsMergedWithTemplateDefs = yield this.agGrid.mergeAllColumnDefsAndStates(columnDefsFromMetadata, true);
            return colDefsMergedWithTemplateDefs;
        });
    }
    buildCriteria() {
        var _a;
        const initialCriteria = ((_a = this.criteria) === null || _a === void 0 ? void 0 : _a.split(criteriaDelimiter)) || [];
        const criteria = initialCriteria.concat(Array.from(this.criteriaFromFilters.values()));
        return normaliseCriteria(criteria.join(criteriaJoin), criteriaDelimiter);
    }
    setFilter(fieldName, newFilter) {
        this.criteriaFromFilters.set(fieldName, newFilter);
        this.update.next(this.criteriaFromFilters);
    }
    removeFilter(fieldName) {
        this.criteriaFromFilters.delete(fieldName);
        this.update.next(this.criteriaFromFilters);
    }
    applyTransaction(agTransaction) {
        return this.agGrid.gridApi.applyTransaction(agTransaction);
    }
    applyTransactionAsync(agTransaction, callback) {
        this.agGrid.gridApi.applyTransactionAsync(agTransaction, callback);
    }
    handleSizeChanged(oldSize, newSize) {
        if (oldSize === newSize)
            return;
        this.$emit(gridProGenesisDatasourceEventNames.sizeChanged, {
            value: newSize,
            oldValue: oldSize,
        });
    }
};
__decorate([
    Auth
], GridProGenesisDatasource.prototype, "auth", void 0);
__decorate([
    Datasource
], GridProGenesisDatasource.prototype, "datasource", void 0);
__decorate([
    attr({ attribute: 'polling-interval' })
], GridProGenesisDatasource.prototype, "pollingInterval", void 0);
__decorate([
    attr({ mode: 'boolean', attribute: 'disable-polling' })
], GridProGenesisDatasource.prototype, "disablePolling", void 0);
__decorate([
    observable
], GridProGenesisDatasource.prototype, "request", void 0);
__decorate([
    attr({ mode: 'boolean', attribute: 'restart-on-reconnection' })
], GridProGenesisDatasource.prototype, "restartOnReconnection", void 0);
__decorate([
    attr({ mode: 'boolean', attribute: 'keep-col-defs-on-clear-row-data' })
], GridProGenesisDatasource.prototype, "keepColDefsOnClearRowData", void 0);
GridProGenesisDatasource = __decorate([
    customElement({
        name: 'grid-pro-genesis-datasource',
    })
], GridProGenesisDatasource);
export { GridProGenesisDatasource };
